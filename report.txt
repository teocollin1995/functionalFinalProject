Compilation (Written by both):

Here is some instructions on how to use the interface:

First run make to compile all the code. Then open index.html and in the input box you can enter the wolframalpha-format input and use compute to compute the result. Also you can plot functions using the plot button.

To use individual libraries (complex, Linear, Calculus) you load them into the repl or include them in whatever. Note that while we are reasonably confident about most functionality, not everything is sure. This is okay because a good portion of what we are unsure of is in not needed for the interface, but was part of an effort to build a more general system. And again, more time will be spent on this in the future as we want to have these be useful for more than just this project. As will be elaborate in Teo's part, you can only use eigen and diagnolziation stuff within a compiled file when you are connected to the internet.

One note when using the interface with eigen stuff. We did not normalize the vectors so they will be off by the norm of the relevant vector. 

what we have accomplished, overall (Written by Bowen):

Our Elm version of WolframAlpha now has most(?) of the core functionalities of the actually wolframalpha, including basic numerical operations, basic functions (the built-in ones), complex numbers and functions, most of the linear algebra library (matrix operations, eigenvalue, eigenvector, diagonalization,etc), some basic calculus functionalities (symbolic differentiation, numeric differentiation, numeric integration) and basic plotting.

However, there are definitely some defects in the functionalities that we have implemented. For example, the interface looks way worse than the actual wolframalpha. Also, the output is not formatted in a way that as informative as the actual wolframalpha output. Moreover, the plotting part is very crude and can only allow plotting in [-1,1] interval (it should be easy to allow the user to choose the domain as they like, but we don't have time for that).

In the implementation of the interface, I used ports to get the user input and the send that to Elm to perform computations. That involves some javascript code and is relatively easy to deal with. The main diffculties I had consist of two parts: dynamically embedding latex into html and web design(!) The reason for embedding latex into html is that we sometimes have matrix as output and hence it would look very ugly in plain text. However, to dynamically render the output in latex takes a lot of energy, for the API that I use to achieve this, which is called MathJax, seems to have some bugs (at least I was unable to use some of the functions they provide), which cause me a lot of trouble trying to get everything working. Eventually I was able to do it in a very hacky way by writing some javascript function that manipulates the html. Another diffculty, which is web design, also causes me a lot of trouble because I guess I don't really know how to design a nice-looking web-page and placing each element in the right position also troubled me...


Note: for symbolic differentiation the command is like "d/dx x", for numeric differentiation the command is like "d/dx x at 1", and for numeric integration the command is like "int x from 1 to 2". You can look at the examples that I included as a reference of how to use the interface.

Notes on the math libraries and tests (Teo):

Complex has not changed that much. A few more functions have been added. If I have time, I will try to write some docs before this is do (we are writting the report now to be safe). we did not get to write tests but since we want to eventually add this as a standalone part of the Elm ecosystem, we will do that eventually.

I am responsible for all the numeric parts of calculus. Numeric differentiation has been added using the symetric diff qoutien with the option for a five point system that has not been implemented because we don't need it. One flaw of this component is that it can't tell if the function isn't actually differentatible (although this makes it rather similar to the TI one or various examples where Wolfram alpha fails to differentaite things numerically properly (see the floor function...)) Numeric integration of course also won't detect if the function isn't integrable... or even if you can evaluate it... it will just fail. In this way, it kind of mirrors the general philosophy that we have had with this project that due to little time, we are just going to have leave it to the user to make sure they aren't giving input that doesn't make mathematical sense. (For exmaple, you can really fuck up eigen stuff if you give a poorly formatted matrix...). However, numeric integration is better than differntiation in some respects because we made it more general. I created partition types, functions for dealing with them, and the option to give your own approxmation function to the approximator. This part also lacks docs. Also, Bowen implemented symbolic differntiation as a nice extension of how he did parsing.

Linear is the main focus of my works. As we added tests, we debugged more and more things. I'm reasonably confident in a portion of the library, but there is still more testing to do before we can consider releasing it as something useful. Also, it needs to comform to Elm's standards in various ways. The docs haven't changed much...

Now, I've avoided the elephant in the room... it seems that not much has changed, well a lot has and it is all due to one thing. Eigenvalues. In the testing process, we discovered the javascript library that we used sucks. You can get some idea of what was wrong in a bug repor that I filed: https://github.com/lvandeve/jmat/issues/13. We searched for another library. Numeric js is one of the few that seemed to work, had tests, and actually allowed me to copy it into my file. Sadly, it could only do complex numbers. What could be worse? Well, it failed any time there was a repeated eigen value... This is pretty bad. It seems that despite how popular javascript is, there is a death of linear algebra libraries. In fact, the only good one is pretty much unusable because it just uses a C binding... well, in retrospect, what does one expect? Even haskell just uses the CFFI to do eigen values. They both actually link to the same c lirbary, by the way. In any event, a new approach was needed and it is wholy absurd/fragile.

Basically, I was tired of this shit so I setup an external server to feed a matrix to and get back the eigen values. The address is "https://eigenserver-1245.appspot.com/ and the code for the server, which uses an appspot template that I had used before is in "eigenServerCode". I wrote elm code to generate a url. I wrote javascript to make an http request (I might have been able to use elm-http, but I ended up just using it as a way of figuring out how to do http requests in javascript...). I then used python/numpy (which is just a c binding sometimes so great) to calculate eigen stuff. This is returned via json. Javascript parses using part of the Jmat library (still useful for something it seems). Elm then just reports it to you. This works, but it is fragile mainly in that it needs an internet connection and has no good way of failing... basically, I went through a lot of hell to get eigen to work so please give it the benifit of the doubt. 

This is not all that I did with Linear. Various other parts were shored up and tests were added for somet things. But this is the most important as it now means you need an internet connection and can't use eigen stuff in the repl, which is sad. If we add eigen stuff to some theoretical library that I would want to give to elm, we would just write in pure js obvious and I will be better equipped to do that soon as I'm taing numerical analysis next quarter.

I also added tests. Using elm-tests, I added a testing system. On top of this, I also integrated it with travis ci so our git (https://github.com/teocollin1995/functionalfinalproject) now has a build passing/failing/errored icon. You can see the ci here: https://travis-ci.org/teocollin1995/functionalfinalproject. Note how absurdly long it takes to test because it needs to download all the libraries again and this takes a while for whatever reason.


Teo's quick reflection:

I think that my experience with native kind of speaks to how I feel about Elm. I really like it, but I find it rather difficient in some regards. It is a young language so that is okay, but it is still annoying as there are just a lot of rough edeges that I found out about...

However, finding all of those out was pretty fun. In fact, I think that one of things that I like most about elm is how easy it for me to understand it. I had many problems that I solved simply by just going into the language source or the generated code. For example, I was having trouble understanding how native worked, but looking through the source really helped a lot. The way elm is built (a high level language that compiles into another high level language) actually makes it kind of easier to understand. I like this a lot... 

So, im summary. Elm is a nice language with a lot of rough edges. Native is a complete hack and feels like an accident of how the language was built. On the other hand, this accident is really fun to investiage and I've learned a lot. Also, screw eigen values.
